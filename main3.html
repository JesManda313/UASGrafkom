<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Three.js BVH Collision</title>
</head>
<body style="margin:0; overflow:hidden;">

<script type="module">
/* --------------------------
  1️⃣ Impor modul via CDN
--------------------------- */
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.167/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.167/examples/jsm/loaders/GLTFLoader.js';
import { MeshBVH, acceleratedRaycast, computeBoundsTree } from 'https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.2/+esm';

/* Patch BVH ke Three.js */
THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
THREE.Mesh.prototype.raycast = acceleratedRaycast;

/* --------------------------
  2️⃣ Inisialisasi scene
--------------------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* Lampu ambient */
scene.add(new THREE.AmbientLight(0xffffff, 1));

/* --------------------------
  3️⃣ Player
--------------------------- */
const playerGeo = new THREE.CircleGeometry(0.05, 16);
const playerMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
const player = new THREE.Mesh(playerGeo, playerMat);
player.rotation.x = -Math.PI/2;
player.position.set(2, 0.05, 2);
scene.add(player);

/* Movement */
const keys = { w:false, s:false, a:false, d:false };
const speed = 0.05;
document.addEventListener("keydown", e => { if(e.code==="KeyW") keys.w=true; if(e.code==="KeyS") keys.s=true; if(e.code==="KeyA") keys.a=true; if(e.code==="KeyD") keys.d=true; });
document.addEventListener("keyup", e => { if(e.code==="KeyW") keys.w=false; if(e.code==="KeyS") keys.s=false; if(e.code==="KeyA") keys.a=false; if(e.code==="KeyD") keys.d=false; });

/* --------------------------
  4️⃣ Load GLB dan setup BVH
--------------------------- */
const loader = new GLTFLoader();
let colliders = []; // semua wall/mesh yang akan di-collide

loader.load("skeld.glb", gltf => {
    const map = gltf.scene;
    scene.add(map);

    map.traverse(obj => {
        if (!obj.isMesh) return;

        // misal kita tentukan wall berdasarkan id
        const match = obj.name.match(/\d+/);
        if(!match) return;
        const id = parseInt(match[0]);
        const wallIDs = [137,139,141,143,64,59,128,32,80,79,105,58,78,44,43,25,128,23,56,66,60,37,115,54,118,8,93,52];
        if(!wallIDs.includes(id)) return;

        // Ganti warna wall
        obj.material = new THREE.MeshStandardMaterial({ color: 0xff0000 });

        // BVH untuk collision detection
        obj.geometry.computeBoundsTree();
        colliders.push(obj);

        // Optional: visualisasi semi-transparan
        const highlight = new THREE.Mesh(obj.geometry, new THREE.MeshBasicMaterial({ color:0x00ff00, transparent:true, opacity:0.3, side:THREE.DoubleSide }));
        highlight.position.copy(obj.position);
        highlight.rotation.copy(obj.rotation);
        highlight.scale.copy(obj.scale);
        obj.add(highlight);
    });

    animate();
});

/* --------------------------
  5️⃣ Camera controls
--------------------------- */
let isMouseDown=false, lastX=0, lastY=0, camRotationX=0.3, camRotationY=0;
document.addEventListener("mousedown", e=>{ isMouseDown=true; lastX=e.clientX; lastY=e.clientY; });
document.addEventListener("mouseup", ()=>{ isMouseDown=false; });
document.addEventListener("mousemove", e=>{
    if(!isMouseDown) return;
    const deltaX = (e.clientX-lastX)*0.01;
    const deltaY = (e.clientY-lastY)*0.01;
    lastX=e.clientX; lastY=e.clientY;
    camRotationY -= deltaX;
    camRotationX += deltaY;
    camRotationX = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, camRotationX));
});

function updateCamera(){
    const center = new THREE.Vector3(player.position.x, 0, player.position.z);
    const distance = 7;
    const x = center.x + distance * Math.cos(camRotationX) * Math.sin(camRotationY);
    const y = center.y + distance * Math.sin(camRotationX);
    const z = center.z + distance * Math.cos(camRotationX) * Math.cos(camRotationY);
    camera.position.set(x,y,z);
    camera.lookAt(center);
}

/* --------------------------
  6️⃣ Collision detection dengan BVH
--------------------------- */
function checkCollision(pos){
    const radius = 0.05;
    const origin = pos.clone();

    for(let wall of colliders){
        // raycast sederhana ke 6 arah untuk mendeteksi collision
        const directions = [ new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1) ];
        for(let dir of directions){
            const ray = new THREE.Raycaster(origin, dir, 0, radius);
            const intersects = ray.intersectObject(wall, true); // true = traverse children
            if(intersects.length>0) return true;
        }
    }
    return false;
}

/* --------------------------
  7️⃣ Animate loop
--------------------------- */
function animate(){
    requestAnimationFrame(animate);
    let newPos = player.position.clone();
    if(keys.w) newPos.z -= speed;
    if(keys.s) newPos.z += speed;
    if(keys.a) newPos.x -= speed;
    if(keys.d) newPos.x += speed;
    if(!checkCollision(newPos)) player.position.copy(newPos);
    updateCamera();
    renderer.render(scene, camera);
}

/* --------------------------
  8️⃣ Resize handler
--------------------------- */
window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
