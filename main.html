<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Three.js Raycast Collision</title>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.167/build/three.module.js",
    "GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.167/examples/jsm/loaders/GLTFLoader.js",
    "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.2/+esm"
  }
}
</script>


</head>
<body style="margin:0; overflow:hidden;">
<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'GLTFLoader';
import {
  acceleratedRaycast,
  computeBoundsTree,
  disposeBoundsTree,
} from "three-mesh-bvh";

THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
THREE.Mesh.prototype.raycast = acceleratedRaycast;

// WALL LIST
const wallIDs = [
  137,139,141,143,64,59,128,32,80,79,
  105,58,78,44,43,25,128,23,56,66,27,64,
  60,37,115,54,118,8,93,52,95,74,72,107,176,185,169,62,168
];

//107 transparan

// SCENE
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff, 1));

// PLAYER
const PLAYER_RADIUS = 0.03;

const player = new THREE.Mesh(
    new THREE.SphereGeometry(PLAYER_RADIUS, 32, 32),
    new THREE.MeshStandardMaterial({ color: 0xff4444 })
);

player.position.set(4.7, PLAYER_RADIUS+0.03, -3.3);
scene.add(player);

// MOVEMENT
const speed = 0.005;
const keys = { w:false, s:false, a:false, d:false };

document.addEventListener("keydown", e=>{
    if(keys.hasOwnProperty(e.code.toLowerCase().replace("key","")))
        keys[e.code.toLowerCase().replace("key","")] = true;
});

document.addEventListener("keyup", e=>{
    if(keys.hasOwnProperty(e.code.toLowerCase().replace("key","")))
        keys[e.code.toLowerCase().replace("key","")] = false;
});

// LOAD MAP + BVH
const loader = new GLTFLoader();
let staticCollidableObjects = [];

loader.load("assets/skeld.glb", gltf=>{
    const map = gltf.scene;
    scene.add(map);

    map.traverse(obj =>{
      if (!obj.isMesh) return;

      const match = obj.name.match(/\d+/);
      if (!match) return;

      const id = parseInt(match[0]);
      if (!wallIDs.includes(id)) return;

      obj.material = new THREE.MeshStandardMaterial({ color: 0xff0000 });

      obj.geometry.computeBoundsTree();

      staticCollidableObjects.push(obj);
    });

    updateCamera();
    animate();
});

// SPHERE vs MESH BVH COLLISION
function sphereMeshCollision(pos) {

    for (let wall of staticCollidableObjects) {
        wall.updateMatrixWorld(true);

        const inverseMatrix = wall.matrixWorld.clone().invert();

        const localCenter = pos.clone().applyMatrix4(inverseMatrix);

        const scale = new THREE.Vector3();
        wall.getWorldScale(scale);

        const localRadius = PLAYER_RADIUS / Math.max(scale.x, scale.y, scale.z);

        const localSphere = new THREE.Sphere(localCenter, localRadius);

        const hit = wall.geometry.boundsTree.intersectsSphere(localSphere);

        if (hit) return true;
    }

    return false;
}

// COLLISION RESPONSE + SLIDING SIMPLE
function smoothCollisionResponse(oldPos, newPos){

    if (!sphereMeshCollision(newPos)){
        return newPos;
    }

    const xOnly = newPos.clone();
    xOnly.z = oldPos.z;
    if (!sphereMeshCollision(xOnly)){
        return xOnly;
    }

    const zOnly = newPos.clone();
    zOnly.x = oldPos.x;
    if (!sphereMeshCollision(zOnly)){
        return zOnly;
    }

    return oldPos;
}

// CAMERA CONTROL
let isMouseDown=false, lastX=0, lastY=0, camRotationX=0.3, camRotationY=0;

document.addEventListener("mousedown", e=>{ isMouseDown=true; lastX=e.clientX; lastY=e.clientY; });
document.addEventListener("mouseup", ()=>{ isMouseDown=false; });
document.addEventListener("mousemove", e=>{
    if(!isMouseDown) return;

    const dx = (e.clientX-lastX)*0.01;
    const dy = (e.clientY-lastY)*0.01;
    lastX=e.clientX; lastY=e.clientY;

    camRotationY -= dx;
    camRotationX += dy;
    camRotationX = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, camRotationX));
});

function updateCamera(){
    const center = new THREE.Vector3(player.position.x, 0, player.position.z);
    const distance = 0.5;

    const x = center.x + distance * Math.cos(camRotationX) * Math.sin(camRotationY);
    const y = center.y + distance * Math.sin(camRotationX);
    const z = center.z + distance * Math.cos(camRotationX) * Math.cos(camRotationY);

    camera.position.set(x,y,z);
    camera.lookAt(center);
}

// LOOP
function animate(){
    requestAnimationFrame(animate);

    const oldPos = player.position.clone();
    const newPos = oldPos.clone();

    if (keys.w) newPos.z -= speed;
    if (keys.s) newPos.z += speed;
    if (keys.a) newPos.x -= speed;
    if (keys.d) newPos.x += speed;

    const finalPos = smoothCollisionResponse(oldPos, newPos);
    player.position.copy(finalPos);

    updateCamera();
    renderer.render(scene, camera);
}

// RESIZE
window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
