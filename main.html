<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Skeld — Among Us Demo</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    #hint, #pos, #dir { position:fixed; left:10px; font-family:Arial; z-index:10; user-select:none; }
    #hint { top:10px; color:#fff; font-size:14px; }
    #pos { top:35px; color:#00ff88; font-size:14px; }
    #dir { top:60px; color:#00bbff; font-size:14px; }
    #camButtons { position:fixed; top:100px; left:10px; display:flex; flex-direction:column; gap:4px; z-index:20; }
    #camButtons button { padding:3px 8px; cursor:pointer; }
  </style>

  <!-- importmap (optional) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.167/build/three.module.js",
      "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.2/+esm"
    }
  }
  </script>
</head>
<body>
  <div id="hint">Click P to switch Camera | X to force 3rd-person</div>
  <div id="pos">X: 0 | Z: 0</div>
  <div id="dir">Yaw: 0° | Pitch: 0°</div>
  <div id="camButtons"></div>

  <script type="module">
  import * as THREE from 'three';
  import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.167/examples/jsm/loaders/RGBELoader.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.167/examples/jsm/loaders/GLTFLoader.js';
  import {
    acceleratedRaycast,
    computeBoundsTree,
    disposeBoundsTree
  } from 'three-mesh-bvh';
  // patch BVH to three geometry prototype
  THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
  THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
  THREE.Mesh.prototype.raycast = acceleratedRaycast;

  // Import player module (local file)
  import { createPlayer } from './character.js';

  // ---------- Basic scene ----------
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 2000);
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);
  scene.add(new THREE.AmbientLight(0xffffff, 1));

  // try to load an HDR background; fallback to color
  new RGBELoader().load(
    'assets/space.hdr',
    tex => { tex.mapping = THREE.EquirectangularReflectionMapping; scene.background = tex; },
    undefined,
    () => { scene.background = new THREE.Color(0x000010); }
  );

  // ---------- Variables ----------
  const PLAYER_RADIUS = 0.03;
  let staticCollidableObjects = [];
  let playerObj = null; // will be set after character load
  let mixer = null;
  let clock = new THREE.Clock();

  // WALL IDs array from your original code (used for BVH selection)
  const wallIDs = [137,139,141,143,64,59,128,32,80,79,18,164,188,105,58,78,44,43,25,128,23,56,66,27,64,33,87,123,60,37,115,54,118,8,93,52,95,74,72,107,176,185,169,62,168];

  // ---------- Camera / UI / Controls state ----------
  const cctvCameras = [
    { name: "Scene 1 Emergency",  x:4.69, z:-3.20, yaw:180, pitch:-5,  height:0.1 },
    { name: "Scene 2 Chair",      x:6.31, z:-3.40, yaw:150, pitch:0,  height:0.1 },
    { name: "Scene 3 Electric",   x:3.49, z:-1.67, yaw:-160, pitch:0, height:0.1 },
    { name: "Scene 4 Scan",       x:5.82, z:-1.81, yaw:-141, pitch:0, height:0.1 },
    { name: "Scene 5 Security",   x:2.38, z:-2.43, yaw:175, pitch:0,  height:0.1 },
    { name: "Scene 6 Hallway",    x:1.78, z:-2.54, yaw:-90, pitch:0,  height:0.1 },
    { name: "Scene 7 Hands",      x:0.96, z:-2.97, yaw:-168, pitch:0, height:0.1 },
    { name: "Scene 8 Hallway",    x:1.78, z:-2.54, yaw:-90, pitch:0,  height:0.1 },
    { name: "Scene 9 Hands",      x:0.96, z:-2.97, yaw:-168, pitch:0, height:0.1 },
    { name: "Scene 10 Empty",     x:0.96, z:-2.97, yaw:-5.5, pitch:0, height:0.1 },
    { name: "Scene 11 Hands",     x:0.96, z:-2.97, yaw:-168, pitch:0, height:0.1 },
    { name: "Scene 12 Peek",      x:0.73, z:-2.31, yaw:180, pitch:0,  height:0.1 },
    { name: "Scene 13 Top",       x:0.73, z:-2.55, yaw:90,  pitch:-90, height:0.4 },
    { name: "Scene 14 Empty",     x:0.96, z:-2.97, yaw:-168, pitch:0, height:0.1 },
    { name: "Scene 15 Vent",      x:0.82, z:-2.06, yaw:133, pitch:0,  height:0.1 },
    { name: "Scene 16 Door",      x:1.20, z:-2.20, yaw:-92.5,pitch:0, height:0.1 },
  ];

  let cctvIndex = -1;
  function setUIVisibility(isVisible){
    const v = isVisible ? 'visible' : 'hidden';
    document.getElementById('pos').style.visibility = v;
    document.getElementById('dir').style.visibility = v;
    document.getElementById('hint').style.visibility = v;
    document.getElementById('camButtons').style.visibility = v;
  }

  // populate camera buttons
  const camContainer = document.getElementById('camButtons');
  cctvCameras.forEach((cam,i)=>{
    const b = document.createElement('button');
    b.innerText = (i+1)+'. '+cam.name;
    b.onclick = ()=> { cctvIndex = i; firstPerson=false; setUIVisibility(false); };
    camContainer.appendChild(b);
  });

  // ---------- Movement & input ----------
  const speed = 0.005;
  const keys = { w:false, s:false, a:false, d:false };

  window.addEventListener('keydown', e=>{
    if(e.code === 'KeyP'){
      if(cctvIndex !== -1){ cctvIndex = -1; firstPerson = true; setUIVisibility(true); }
      else firstPerson = !firstPerson;
    } else if(e.code === 'KeyX') { cctvIndex = -1; firstPerson=false; setUIVisibility(true); }
    else {
      const k = e.code.toLowerCase().replace('key','');
      if(keys.hasOwnProperty(k)) keys[k] = true;
    }
  });
  window.addEventListener('keyup', e=>{
    const k = e.code.toLowerCase().replace('key','');
    if(keys.hasOwnProperty(k)) keys[k] = false;
  });

  // mouse controls (for looking / orbit)
  let isMouseDown=false, lastX=0, lastY=0;
  let camRotationX = 0.3, camRotationY = 0;
  let yaw = 0, pitch = 0;
  const PITCH_LIMIT = Math.PI/2 - 0.01;
  window.addEventListener('mousedown', e=>{ isMouseDown=true; lastX=e.clientX; lastY=e.clientY; });
  window.addEventListener('mouseup', ()=> isMouseDown=false);
  window.addEventListener('mousemove', e=>{
    if(!isMouseDown) return;
    const dx = (e.clientX-lastX)*0.002, dy = (e.clientY-lastY)*0.002;
    lastX = e.clientX; lastY = e.clientY;
    if(firstPerson){
      yaw -= dx; pitch -= dy; pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
    } else {
      camRotationY -= dx; camRotationX += dy;
      camRotationX = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, camRotationX));
    }
  });

  let firstPerson = false;

  // ---------- Load map and BVH ----------
  const gltfLoader = new GLTFLoader();
  gltfLoader.load('assets/skeld.glb', gltf=>{
    const map = gltf.scene;
    scene.add(map);

    map.traverse(obj=>{
      if(!obj.isMesh) return;

      // hide some objects if desired (from your original code)
      if(obj.name === 'Object_6' || obj.name === 'Object_87'){
        obj.visible = false;
        return;
      }

      // special material for certain object
      if(obj.name === 'Object_107'){
        const texLoader = new THREE.TextureLoader();
        const envTex = texLoader.load('assets/space.hdr');
        envTex.mapping = THREE.EquirectangularReflectionMapping;
        obj.material = new THREE.MeshPhysicalMaterial({
          color: 0x88ccee, transparent:true, opacity:0.45, roughness:0.05, metalness:0.1,
          reflectivity:0.9, clearcoat:1.0, clearcoatRoughness:0.05, envMap: envTex
        });
      }

      const m = obj.name.match(/\d+/);
      if(!m) return;
      const id = parseInt(m[0]);
      if(!wallIDs.includes(id)) return;

      // prepare BVH
      obj.geometry.computeBoundsTree();
      staticCollidableObjects.push(obj);
    });

    // after map loaded, create player
    (async ()=>{
        playerObj = await createPlayer(scene, new THREE.Vector3(4.7, PLAYER_RADIUS-0.025, -3.3));
        mixer = playerObj.mixer;
        updateCamera();
        console.log(playerObj);
        animate();
    })();
  }, undefined, err=>console.error('load skeld error', err));

  // ---------- collision helpers (sphere vs BVH meshes) ----------
  function sphereMeshCollision(pos){
    if(!staticCollidableObjects.length) return false;
    for(const wall of staticCollidableObjects){
      wall.updateMatrixWorld(true);
      const inverse = wall.matrixWorld.clone().invert();
      const colliderOffset = new THREE.Vector3(0, 0.035, 0);
      const localCenter = pos.clone().add(colliderOffset).applyMatrix4(inverse);

      const scale = new THREE.Vector3();
      wall.getWorldScale(scale);
      const localRadius = PLAYER_RADIUS / Math.max(scale.x, scale.y, scale.z);
      const localSphere = new THREE.Sphere(localCenter, localRadius);

      const hit = wall.geometry.boundsTree.intersectsSphere(localSphere);
      if(hit) return true;
    }
    return false;
  }

  function smoothCollisionResponse(oldPos, newPos){
    if(!sphereMeshCollision(newPos)) return newPos;
    const xOnly = newPos.clone(); xOnly.z = oldPos.z; if(!sphereMeshCollision(xOnly)) return xOnly;
    const zOnly = newPos.clone(); zOnly.x = oldPos.x; if(!sphereMeshCollision(zOnly)) return zOnly;
    return oldPos;
  }

  // ---------- camera update ----------
  function updateCamera(){
    if(cctvIndex !== -1){
      const cam = cctvCameras[cctvIndex];
      camera.position.set(cam.x, cam.height, cam.z);
      const dir = new THREE.Vector3(Math.sin(cam.yaw*Math.PI/180)*Math.cos(cam.pitch*Math.PI/180),
                                    Math.sin(cam.pitch*Math.PI/180),
                                    Math.cos(cam.yaw*Math.PI/180)*Math.cos(cam.pitch*Math.PI/180));
      camera.lookAt(cam.x + dir.x, cam.height + dir.y, cam.z + dir.z);
      return;
    }

    if(!playerObj) return;

    if(firstPerson){
      const eye = playerObj.mesh.position.clone();
      camera.position.copy(eye);
      const forward = new THREE.Vector3(Math.sin(yaw)*Math.cos(pitch), Math.sin(pitch), Math.cos(yaw)*Math.cos(pitch));
      camera.lookAt(eye.clone().add(forward));
    } else {
      const center = new THREE.Vector3(playerObj.mesh.position.x, 0, playerObj.mesh.position.z);
      const dist = 2;
      const x = center.x + dist*Math.cos(camRotationX)*Math.sin(camRotationY);
      const y = center.y + dist*Math.sin(camRotationX);
      const z = center.z + dist*Math.cos(camRotationX)*Math.cos(camRotationY);
      camera.position.set(x,y,z);
      camera.lookAt(center);
    }
  }

  function getFPSDirection(){
    const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; return dir.normalize();
  }
  function getFPSRight(fwd){ return new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)); }

  // ---------- main loop ----------
  function animate(){
    requestAnimationFrame(animate);
    
    const delta = clock.getDelta();
    if(!playerObj){
        renderer.render(scene, camera);
        return;
    }

    // generate movement data
    const oldPos = playerObj.mesh.position.clone();
    const newPos = oldPos.clone();
    let moving = false;

    if(firstPerson){
      const fwd = getFPSDirection();
      const right = getFPSRight(fwd);

      const dir = new THREE.Vector3();

      if(keys.w) dir.add(fwd);
      if(keys.s) dir.sub(fwd);
      if(keys.a) dir.sub(right);
      if(keys.d) dir.add(right);

      if(dir.lengthSq() > 0){
          dir.normalize();
          newPos.addScaledVector(dir, speed);
          moving = true;
      }

    } else {

      const dir = new THREE.Vector3();

      if(keys.w) dir.z -= 1;
      if(keys.s) dir.z += 1;
      if(keys.a) dir.x -= 1;
      if(keys.d) dir.x += 1;

      if(dir.lengthSq() > 0){
          dir.normalize();
          newPos.addScaledVector(dir, speed);
          moving = true;
      }
    }


    const finalPos = smoothCollisionResponse(oldPos, newPos);

    // CALL UPDATE ON PLAYER MODULE
    playerObj.update(delta, {
        position: finalPos,
        oldPosition: oldPos,
        isMoving: moving
    });

    // update UI
    document.getElementById('pos').innerText =
      "X: " + finalPos.x.toFixed(2) + " | Z: " + finalPos.z.toFixed(2);

    const v = new THREE.Vector3();
    camera.getWorldDirection(v);
    const yawDeg   = Math.atan2(v.x, v.z) * 180 / Math.PI;
    const pitchDeg = Math.asin(v.y) * 180 / Math.PI;
    document.getElementById('dir').innerText =
      "Yaw: " + yawDeg.toFixed(1) + "° | Pitch: " + pitchDeg.toFixed(1) + "°";

    updateCamera();
    renderer.render(scene, camera);
  }

  // resize
  window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

  </script>
</body>
</html>
