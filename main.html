<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Skeld â€” Among Us Demo</title>
<style>
    body { margin:0; overflow:hidden; background:#000; }
    #hint, #pos, #dir { position:fixed; left:10px; font-family:Arial; z-index:10; user-select:none; }
    #hint { top:10px; color:#fff; font-size:14px; }
    #pos { top:35px; color:#00ff88; font-size:14px; }
    #dir { top:60px; color:#00bbff; font-size:14px; }
    #camButtons { position:fixed; top:100px; left:10px; display:flex; flex-direction:column; gap:4px; z-index:20; }
    #camButtons button { padding:3px 8px; cursor:pointer; }
</style>

<script type="importmap">
{
    "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.167/build/three.module.js",
    "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.2/+esm"
    }
}
</script>
</head>
<body>
<div id="hint">Click P to switch Camera | X to force 3rd-person</div>
<div id="pos">X: 0 | Z: 0</div>
<div id="dir">Yaw: 0Â° | Pitch: 0Â°</div>
<div id="camButtons"></div>

<script type="module">
import * as THREE from "three";
import { RGBELoader } from "https://cdn.jsdelivr.net/npm/three@0.167/examples/jsm/loaders/RGBELoader.js";
import {
    acceleratedRaycast,
    computeBoundsTree,
    disposeBoundsTree
} from "three-mesh-bvh";

THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
THREE.Mesh.prototype.raycast = acceleratedRaycast;

import { createPlayer } from "./character.js";
import { loadMap } from "./map.js";
// ðŸ’¡ IMPOR FUNGSI KONTROLER SCENE 2
import { 
    initializeScene2, 
    clearScene2, 
    updateScene2
} from "./Scene/2.js"; 
import { 
    initializeScene6, 
    clearScene6, 
    updateScene6
} from "./Scene/6.js"; 

// SCENE
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.01, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff, 1));

new RGBELoader().load(
    "assets/space.hdr",
    tex => { tex.mapping = THREE.EquirectangularReflectionMapping; scene.background = tex },
    undefined,
    () => { scene.background = new THREE.Color(0x000010) }
);

// VARIABLES
const PLAYER_RADIUS = 0.05;
let staticCollidableObjects = [];
let playerObj = null;
let mixer = null;
let clock = new THREE.Clock();
let cameraDistance = 2; 

const wallIDs = [137,139,141,143,64,59,128,32,80,79,18,164,188,105,58,78,44,43,25,128,23,56,66,27,64,33,87,123,60,37,115,54,118,8,93,52,95,74,72,107,176,185,169,62,168];

// CAMERA CONTROLS
const cctvCameras = [
    { name:"Scene 1 Emergency", x:4.69, z:-3.20, yaw:180, pitch:-5, height:0.1, id:1 },
    { name:"Scene 2 Chair", x:6.31, z:-3.40, yaw:150, pitch:0, height:0.1, id:2 }, // Index 1
    { name:"Scene 3 Electric", x:3.49, z:-1.67, yaw:-160, pitch:0, height:0.1, id:3 },
    { name:"Scene 4 Scan", x:5.82, z:-1.81, yaw:-141, pitch:0, height:0.1, id:4 },
    { name:"Scene 5 Security", x:2.38, z:-2.43, yaw:175, pitch:0, height:0.1, id:5 },
    { name:"Scene 6 Hallway", x:1.78, z:-2.54, yaw:-90, pitch:0, height:0.1, id:6 },
    { name:"Scene 7 Hands", x:0.96, z:-2.97, yaw:-168, pitch:0, height:0.1, id:7 },
    { name:"Scene 8 Hallway", x:1.78, z:-2.54, yaw:-90, pitch:0, height:0.1, id:8 },
    { name:"Scene 9 Hands", x:0.96, z:-2.97, yaw:-168, pitch:0, height:0.1, id:9 },
    { name:"Scene 10 Empty", x:0.96, z:-2.97, yaw:-5.5, pitch:0, height:0.1, id:10 },
    { name:"Scene 11 Hands", x:0.96, z:-2.97, yaw:-168, pitch:0, height:0.1, id:11 },
    { name:"Scene 12 Peek", x:0.73, z:-2.31, yaw:180, pitch:0, height:0.1, id:12 },
    { name:"Scene 13 Top", x:0.73, z:-2.55, yaw:90, pitch:-90, height:0.4, id:13 },
    { name:"Scene 14 Empty", x:0.96, z:-2.97, yaw:-168, pitch:0, height:0.1, id:14 },
    { name:"Scene 15 Vent", x:0.82, z:-2.06, yaw:133, pitch:0, height:0.1, id:15 },
    { name:"Scene 16 Door", x:1.20, z:-2.20, yaw:-92.5, pitch:0, height:0.1, id:16 },
];

let cctvIndex = -1;

function setUIVisibility(v){
    const k = v ? "visible" : "hidden";
    document.getElementById("pos").style.visibility = k;
    document.getElementById("dir").style.visibility = k;
    document.getElementById("hint").style.visibility = k;
    document.getElementById("camButtons").style.visibility = k;
}

const camContainer = document.getElementById("camButtons");
cctvCameras.forEach((cam,i)=>{
    const b = document.createElement("button");
    b.innerText = (i+1) + ". " + cam.name;
    b.onclick = ()=>{ 
        cctvIndex = i; 
        firstPerson = false; 
        setUIVisibility(false);
        
        // ðŸ’¡ PANGGILAN FUNGSI SCENE 2 DARI KONTROLER
        if(i === 1){
            initializeScene2(scene, createPlayer, playerObj); 
        } 
        else if(i === 5){
            initializeScene6(scene, createPlayer);
        }
        else {
            clearScene2();
            clearScene6();
        }
    };
    camContainer.appendChild(b);
});

// MOVEMENT
const speed = 0.005;
const keys = { w:false, a:false, s:false, d:false };

window.addEventListener("keydown", e=>{
    if(e.code === "KeyP"){
    if(cctvIndex !== -1){ cctvIndex = -1; firstPerson = true; setUIVisibility(true); clearScene2(); clearScene6();}
    else firstPerson = !firstPerson;
    } else if(e.code === "KeyX"){
    cctvIndex = -1;
    firstPerson = false;
    setUIVisibility(true);
    clearScene2(); // Memastikan Scene 2 dibersihkan
    clearScene6();
    } else {
    const k = e.code.toLowerCase().replace("key","");
    if(keys.hasOwnProperty(k)) keys[k] = true;
    }
});

window.addEventListener("keyup", e=>{
    const k = e.code.toLowerCase().replace("key","");
    if(keys.hasOwnProperty(k)) keys[k] = false;
});

let isMouseDown = false, lastX = 0, lastY = 0;
let camRotationX = 0.3, camRotationY = 0;
let yaw = 0, pitch = 0;
const PITCH_LIMIT = Math.PI/2 - 0.01;

window.addEventListener("mousedown", e=>{
    isMouseDown = true;
    lastX = e.clientX;
    lastY = e.clientY;
});
window.addEventListener("mouseup", ()=> isMouseDown = false);

window.addEventListener("mousemove", e=>{
    if(!isMouseDown) return;

    const dx = (e.clientX-lastX)*0.002;
    const dy = (e.clientY-lastY)*0.002;
    lastX = e.clientX;
    lastY = e.clientY;

    if(firstPerson){
    yaw -= dx;
    pitch -= dy;
    pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
    } else {
    camRotationY -= dx;
    camRotationX += dy;
    camRotationX = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, camRotationX));
    }
});

window.addEventListener("wheel", e => {
    cameraDistance += e.deltaY * 0.002;
    cameraDistance = Math.min(Math.max(cameraDistance, 0.3), 4); 
});


let firstPerson = false;

// LOAD MAP
(async()=>{
    const result = await loadMap(wallIDs);
    const map = result.map;
    staticCollidableObjects = result.staticCollidableObjects;

    scene.add(map);

    playerObj = await createPlayer(scene, new THREE.Vector3(4.7, 0.005, -3.3));
    mixer = playerObj.mixer;
    playerObj.mesh.visible = true;

    updateCamera();
    animate();
})();

// COLLISION
function sphereMeshCollision(pos){
    if(!staticCollidableObjects.length) return false;

    for(const wall of staticCollidableObjects){
    wall.updateMatrixWorld(true);

    const inverse = wall.matrixWorld.clone().invert();
    const colliderOffset = new THREE.Vector3(0, 0.035, 0);
    const localCenter = pos.clone().add(colliderOffset).applyMatrix4(inverse);

    const scale = new THREE.Vector3();
    wall.getWorldScale(scale);
    const localRadius = PLAYER_RADIUS / Math.max(scale.x, scale.y, scale.z);

    const sphere = new THREE.Sphere(localCenter, localRadius);
    const hit = wall.geometry.boundsTree.intersectsSphere(sphere);
    if(hit) return true;
    }
    return false;
}

function smoothCollisionResponse(oldPos, newPos){
    if(!sphereMeshCollision(newPos)) return newPos;

    const xOnly = newPos.clone();
    xOnly.z = oldPos.z;
    if(!sphereMeshCollision(xOnly)) return xOnly;

    const zOnly = newPos.clone();
    zOnly.x = oldPos.x;
    if(!sphereMeshCollision(zOnly)) return zOnly;

    return oldPos;
}

// CAMERA UPDATE
function updateCamera(){
    if(cctvIndex !== -1){
    const cam = cctvCameras[cctvIndex];
    
    camera.position.set(cam.x, cam.height, cam.z);

    const dir = new THREE.Vector3(
        Math.sin(cam.yaw*Math.PI/180)*Math.cos(cam.pitch*Math.PI/180),
        Math.sin(cam.pitch*Math.PI/180),
        Math.cos(cam.yaw*Math.PI/180)*Math.cos(cam.pitch*Math.PI/180)
    );

    camera.lookAt(
        cam.x + dir.x,
        cam.height + dir.y,
        cam.z + dir.z
    );
    return;
    }

    if(!playerObj) return;

    // Tampilkan/Sembunyikan karakter user
    if(playerObj) playerObj.mesh.visible = !firstPerson;

    if(firstPerson){
        if(playerObj && playerObj.mesh) playerObj.mesh.visible = false;
        const eye = playerObj.mesh.position.clone();
        camera.position.set(eye.x, eye.y + PLAYER_RADIUS*2, eye.z);
        const forward = new THREE.Vector3(
            Math.sin(yaw)*Math.cos(pitch),
            Math.sin(pitch),
            Math.cos(yaw)*Math.cos(pitch)
        );
        camera.lookAt(eye.clone().add(forward));
    } else {
        const center = new THREE.Vector3(
            playerObj.mesh.position.x,
            0,
            playerObj.mesh.position.z
        );
        const x = center.x + cameraDistance * Math.cos(camRotationX) * Math.sin(camRotationY);
        const y = center.y + cameraDistance * Math.sin(camRotationX);
        const z = center.z + cameraDistance * Math.cos(camRotationX) * Math.cos(camRotationY);

        camera.position.set(x,y,z);
        camera.lookAt(center);
    }
}

function getFPSDirection(){
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0;
    return dir.normalize();
}

function getFPSRight(fwd){
    return new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0));
}

// MAIN LOOP
function animate(){
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    if(!playerObj){
        renderer.render(scene, camera);
        return;
    }

    // Scene controller
        const isScene2Running = updateScene2(delta);
        const isScene6Running = updateScene6(delta);

        // Player hanya bergerak kalau scene custom tidak aktif
        if(!isScene2Running && !isScene6Running && cctvIndex === -1) {

        const oldPos = playerObj.mesh.position.clone();
        const newPos = oldPos.clone();
        let moving = false;

        if(firstPerson){
            const fwd = getFPSDirection();
            const right = getFPSRight(fwd);
            const dir = new THREE.Vector3();

            if(keys.w) dir.add(fwd);
            if(keys.s) dir.sub(fwd);
            if(keys.a) dir.sub(right);
            if(keys.d) dir.add(right);

            if(dir.lengthSq() > 0){
                dir.normalize();
                newPos.addScaledVector(dir, speed);
                moving = true;
            }
        } else {
            // Arah kamera
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

            const dir = new THREE.Vector3();

            if(keys.w) dir.add(forward);
            if(keys.s) dir.sub(forward);
            if(keys.a) dir.sub(right);
            if(keys.d) dir.add(right);

            if(dir.lengthSq() > 0){
                dir.normalize();
                newPos.addScaledVector(dir, speed);
                moving = true;
            }
        }

        const finalPos = smoothCollisionResponse(oldPos, newPos);

        playerObj.update(delta, {
            position: finalPos,
            oldPosition: oldPos,
            isMoving: moving
        });

        document.getElementById("pos").innerText = 
        "X: " + finalPos.x.toFixed(2) + " | Z: " + finalPos.z.toFixed(2);

        const v = new THREE.Vector3();
        camera.getWorldDirection(v);

        const yawDeg = Math.atan2(v.x, v.z) * 180 / Math.PI;
        const pitchDeg = Math.asin(v.y) * 180 / Math.PI;

        document.getElementById("dir").innerText =
        "Yaw: " + yawDeg.toFixed(1) + "Â° | Pitch: " + pitchDeg.toFixed(1) + "Â°";
    }

    updateCamera();
    renderer.render(scene, camera);
}

window.addEventListener("resize", ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

</script>
</body>
</html>